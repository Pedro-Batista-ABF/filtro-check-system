
// This file is automatically generated. Do not edit it directly.
import { createClient } from '@supabase/supabase-js';
import type { Database } from './types';

const SUPABASE_URL = "https://yjcyebiahnwfwrcgqlcm.supabase.co";
const SUPABASE_PUBLISHABLE_KEY = "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InlqY3llYmlhaG53ZndyY2dxbGNtIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NDQ0OTg0MzUsImV4cCI6MjA2MDA3NDQzNX0.MsHyZ9F4nVv0v9q8D7iQK4qgVmxUMdCAxKQun3GuSG4";

// Configurações personalizadas para o cliente Supabase com melhorias para persistência e refresh automático
const options = {
  auth: {
    persistSession: true,
    autoRefreshToken: true,
    detectSessionInUrl: true,
    storageKey: 'supabase.auth.token',
    storage: localStorage,
    flowType: 'implicit',
  },
  global: {
    headers: {
      'apikey': SUPABASE_PUBLISHABLE_KEY,
      'Content-Type': 'application/json'
    },
  },
  realtime: {
    params: {
      eventsPerSecond: 10,
    },
  },
  // Aumentar o timeout global para 10 segundos
  fetch: (url: string, options: RequestInit) => {
    const controller = new AbortController();
    const timeoutId = setTimeout(() => controller.abort(), 10000);
    
    return fetch(url, {
      ...options,
      signal: controller.signal,
    }).finally(() => clearTimeout(timeoutId));
  }
};

// Import the supabase client like this:
// import { supabase } from "@/integrations/supabase/client";

export const supabase = createClient<Database>(SUPABASE_URL, SUPABASE_PUBLISHABLE_KEY, options);

// Configurar interceptor para atualizar headers em todas as requisições
const originalFetch = supabase.rest.headers;
supabase.rest.headers = async () => {
  const { data } = await supabase.auth.getSession();
  const baseHeaders = await originalFetch();
  
  if (data.session?.access_token) {
    return {
      ...baseHeaders,
      'Authorization': `Bearer ${data.session.access_token}`
    };
  }
  
  return baseHeaders;
};

// Log inicial para verificar a inicialização do cliente Supabase
console.log("Cliente Supabase inicializado com persistência aprimorada");

// Verificar sessão inicial
supabase.auth.getSession().then(async ({ data, error }) => {
  if (error) {
    console.error("Erro ao obter sessão inicial:", error);
  } else if (data.session) {
    console.log(`Sessão inicial encontrada: ${data.session.user.id}`);
    
    // Verificar quando o token expira
    const expiresAt = data.session.expires_at * 1000;
    const now = Date.now();
    const timeToExpire = expiresAt - now;
    console.log(`Token expira em: ${Math.floor(timeToExpire / 60000)} minutos`);
    
    if (timeToExpire < 300000) { // menos de 5 minutos
      console.log("Token próximo de expirar, renovando...");
      // Use imported function from utils instead of referring to itself
      const { refreshAuthSession } = await import('@/utils/connectionUtils');
      refreshAuthSession().then(refreshed => {
        console.log(`Renovação automática do token: ${refreshed ? 'SUCESSO' : 'FALHA'}`);
      });
    }
    
    // Verificar se o token é válido com uma requisição de teste
    try {
      const { error: testError } = await supabase.from('profiles').select('id').limit(1);
      if (testError) {
        console.warn("Sessão inválida ou token expirado, tentando renovar...");
        const { refreshAuthSession } = await import('@/utils/connectionUtils');
        await refreshAuthSession();
      } else {
        console.log("Sessão validada com sucesso");
      }
    } catch (e) {
      console.error("Erro ao validar sessão:", e);
    }
  } else {
    console.log("Nenhuma sessão inicial encontrada");
  }
});

// Import and re-export the utility functions
import {
  checkSupabaseConnection,
  checkSupabaseStatus,
  checkSupabaseAuth,
  refreshAuthSession,
  logAuthStatus,
  performFullConnectivityTest
} from '@/utils/connectionUtils';

export {
  checkSupabaseConnection,
  checkSupabaseStatus,
  checkSupabaseAuth,
  refreshAuthSession,
  logAuthStatus,
  performFullConnectivityTest
};

// Criar uma função que obtenha os headers de autenticação atuais
export const getAuthHeaders = async () => {
  const { data } = await supabase.auth.getSession();
  
  // Se tiver uma sessão, use o access_token do usuário
  if (data.session?.access_token) {
    return {
      'Authorization': `Bearer ${data.session.access_token}`,
      'apikey': SUPABASE_PUBLISHABLE_KEY
    };
  }
  
  // Caso contrário, use apenas a chave pública
  return {
    'apikey': SUPABASE_PUBLISHABLE_KEY
  };
};

// Função para fazer fetch com headers de autenticação atualizados
export const fetchWithAuth = async (url: string, options: RequestInit = {}) => {
  const headers = await getAuthHeaders();
  
  return fetch(url, {
    ...options,
    headers: {
      ...headers,
      ...options.headers,
      'Content-Type': 'application/json',
    },
  });
};

// Verificar eventos de autenticação com melhor logging
supabase.auth.onAuthStateChange((event, session) => {
  console.log(`Evento de autenticação: ${event}`);
  
  if (event === 'SIGNED_IN') {
    console.log('Usuário autenticado com sucesso');
    localStorage.setItem('last_auth_event', JSON.stringify({
      event: 'SIGNED_IN',
      timestamp: Date.now(),
      userId: session?.user?.id
    }));
  } else if (event === 'SIGNED_OUT') {
    console.log('Usuário desconectado');
    localStorage.setItem('last_auth_event', JSON.stringify({
      event: 'SIGNED_OUT',
      timestamp: Date.now()
    }));
  } else if (event === 'TOKEN_REFRESHED') {
    console.log('Token atualizado automaticamente');
    if (session) {
      const expiresAt = session.expires_at * 1000;
      const now = Date.now();
      const timeToExpire = expiresAt - now;
      console.log(`Token atualizado expira em: ${Math.floor(timeToExpire / 60000)} minutos`);
      localStorage.setItem('last_token_refresh', JSON.stringify({
        timestamp: Date.now(),
        expiresAt: expiresAt
      }));
    }
  }
});
